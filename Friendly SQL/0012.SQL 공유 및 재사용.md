# SQL 공유 및 재사용


## 소프트 파싱 vs 하드파싱
SQL 파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간을 라이브 캐시라고 한다.  라이브러리 캐시는 SGA 구성요소다. SGA(System Global Area)는 서버 프로세스와 백그라운드 프로세스가 공통으로 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간이다. 

사용자가 SQL문을 전달하면 DBMS는 SQL을 파싱한 후 해당 SQL이 라이브러리 캐시에 존재하는지부터 확인한다. 캐시에서 찾으면 곧바로 실행 단계로 넘어가지만, 찾지 못하면 최적화 단계를 거친다. SQL을 캐시에서 찾아 곧바로 실행단계로 넘어가는 것을 __소프트파싱__ 이라고 하고, 찾는데 실패해 최적화 및 로우 소스 생성 단계까지 모두 거치는 것을 __하드파싱__ 이라고 한다. 



내비게이션을 예로 들어, 서울에서 부산까지 이동경로는 몇 개나 될까? 모든 도로를 총망라해서 이동 경로를 찾고 도착시간을 계산하려면 긴 시간이 걸린다. 
모든 경우의 수를 다 고려하는 것은 불가능하므로 가능성이 높은 주요 도로 중심으로 후보군을 뽑고 그 중 가장 빠른 길을 선택하는 방식일 텐데, 그럼에도 보통 3~10초 가량 소요되는걸 보면, 최적 경로 탐색이 꽤 어렵고 무거운 작업임을 짐작할 수 있다. 

옵티마이저가 SQL을 최적화할 때도 데이터베이스 사용자들이 보통 생각하는 것보다 훨씬 많은 일을 수행한다. 예를 들어서, 다섯 개 테이블을 조인하는 쿼리문 하나를 최적화하는 데도 무수히 많은 경우의 수가 존재한다. 조인 순서만 고려해도 120가지다. 여기에 NL조인, 소트머지 조인, 해시 조인 등 다양한 조인 방식이 있다. 테이블 전체를 스캔할지, 인덱스를 이용할지를 결정해야 하고, 인덱스 스캔에도 Index Range Scan, Index Unique Scan, Index Full Scan, Index Fast Full Scan, Index Skip Scan 등 다양한 방식이 제공된다. 게다가, 사용할 수 있는 인덱스가 테이블당 하나뿐이겠는가. 

대충 계산해도 수십만 가지 경우의 수가 존재한다. 알고리즘과 하드웨어가 발전하면서 워낙 빠르게 처리하다 보니 잘 느끼지 못하겠지만, SQL 옵티마이저는 순식간에 엄청나게 많은 연산을 한다. 그 과정에 옵티마이저가 사용하는 정보는 다음과 같다. 

* 테이블, 컬럼, 인텍스 구조에 관한 기본 정보
* 오브젝트 통계: 테이블 통계, 인덱스 통계, 컬럼 통계
* 시스템 통계: CPU 속도, Single Block I/O 속도, Multiblock I/O 속도 등 
* 옵티마이저 관련 파라미터

하나의 쿼리를 수행하는 데 있어 후보군이 될만한 무수히 많은 실행경로를 도출하고, 짧은 순간에 딕셔너리와 통계정보를 읽어 각각에 대한 효율성을 판단하는 과정은 결코 가벼울 수 없다. 데이터베이스에서 이루어지는 처리 과정은 대부분 I/O 작업에 집중되는 반면, 하드 파싱은 CPU를 많이 소비하는 몇 안되는 작업 중 하나다. 이렇게 어려운 작업을 거쳐 생성한 내부 프로시저를 한번 사용하고 버린다면 비효율적이기 때문에 라이브러리 캐시가 필요한 이유가 바로 여기에 있다. 




## 바인드 변수의 중요성

### 이름없는 SQL 문제
사용자 정의 ㅎ마수/프로시저, 트리거, 패키지 등은 생성할 때부터 이름을 갖는다. 컴파일한 상태로 딕셔너리에 저장되며, 사용자가 삭제하지 않는 한 영구적으로 보관된다. 실행할 때 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용한다. 
반면 SQL은 이름이 따로 없다. 전체 SQL 텍스트가 일믕 역할을 한다. 딕셔너리에 저장하지도 않는다. 처음 실행할 때 최적화 과정을 거쳐 동적으로 생성한 내부 프로시저를 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용한다. 캐시 공간이 부족하면 버려졌다가 다음에 다시 실행할 때 똑같은 최적화 과정을 거쳐 캐시에 적재된다. 

사용자 정의 함수/프로시저는 내용을 수정해도 이름이 변하지 않으므로 같은 프로그램이 무한 생성되지 않는다. 그런데 SQL은 이름이 따로 없다. SQL 자체가 이름이기 때문에 텍스트 중 작은 부분이라도 수정되면 그 순간 다른 객체가 새로 탄생하는 구조다.  

DBMS에서 수행되는 SQL이 모두 완성된 SQL은 아니며, 특히 개발 과정에는 수시로 변경이 일어난다. 일회성(ad hoc)SQL도 많다. 일회성 또는 무효화된 SQL까지 모두 저장하려면 많은 공간이 필요하고, 그만큼 SQL을 찾는 속도도 느려진다. 


### 공유 가능 SQL
라이브러리 캐시에서 SQL을 찾기 위해 사용하는 키 값이 __SQL문 그 자체__ 이므로 아래는 모두 다른 SQL이다. 의미적으로는 모두 같지만, 실행할 때 각각 최적화를 진행하고 라이브러리 캐시에서 별도 공간을 사용한다. 

```sql

SELECT * FROM emp WHERE empno = 7900;
select * from EMP where EMPNO = 7900;
select * from emp where empno = 7900;
select * FROM emp where empno = 7900   ;
select * FROM emp where empno = 7900       ;
select * FROM scott.emp where empno = 7900;
select /* comment */ * from emp where empno = 7900;
select /*+ first_rows */ * from emp where empno = 7900;
```

아래와 같은 프로그램이 작성되었다고 할 때
```js

async function loginQuery(loginId){
	...

	const sql = "SELECT * FROM CUSTOMER WHERE LOGIN_ID='" + loginId + "'";
	const result = await connection.query(sql);
	
	...
}
```
위와 같은 쿼리로 작성된 프로그램에서 동시다발적으로 발생하는 로그인 요청이 발생하면, 그 순간 라이브러리 캐시를 조회해보면, 아래와 같은 SQL로 가득 차있다.

```sql
SELECT * FROM CUSTOMER WHERE LOGIN_ID= 'kim'
SELECT * FROM CUSTOMER WHERE LOGIN_ID= 'lho'
SELECT * FROM CUSTOMER WHERE LOGIN_ID= 'iktn'
```
로그인 프로그램을 이렇게 작성하면, 고객이 로그인할 때마다 아래와 같이 DBMS 내부 프로시저를 하나씩 만들어서 라이브러리 캐시에 적재하는 셈이다. 내부 프로시저 만드는 역할을 SQL 옵티마이저와 로우 소스 생성기가 담당한다고 앞서 설명했다. 

```sql
create procedure LOGIN_KIM(){...}
create procedure LOGIN_LHO(){...}
create procedure LOGIN_IKTN(){...}
```
위 프로시저의 내부 처리 루틴은 모두 같다. 그렇다면 프로시저를 여러 개 생성할 것이 아니라 아래 처럼 로그인 ID를 파리미터로 받는 프로시저 하나를 공유하면서 재사용하는 것이 마땅하다. 

```sql
create procedure LOGIN(login_id in varchar2){...}
```
이처럼 파라미터 Driven 방식으로 SQL을 작성하는 방법이 제공되는데, 바인드 변수가 바로 그것이다. 

```js

async function loginExecute(loginId){
	...

	const sql = "SELECT * FROM CUSTOMER WHERE LOGIN_ID=?";
	const result = await connection.execute(sql,[loginId]);
	
	...
}
```
라이브러리 캐시를 조회해 보면, 로그인과 관련된 아래 SQL 하나만 발견된다.
```sql
SELECT * FROM CUSTOMER WHERE LOGIN_ID= :1 
```



이 SQL에 대한 하드파싱은 최초 한번만 일어나고, 캐싱된 SQL을 모든 고객이 공유하면서 재사용할 수 있다. 








