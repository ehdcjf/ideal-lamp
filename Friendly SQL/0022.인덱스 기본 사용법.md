# 인덱스 기본 사용법

## 인덱스를 사용한다는 것
인덱스 컬럼(정확히 말하면, 선두 컬럼)을 가공하지 않아야 인덱스를 정상적으로 사용할 수 있다. 인덱스를 정상적으로 사용한다는 표현은 리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미한다. 즉 리프 블록 일부만 스캔하는 Index Range Scan을 의미한다. 

인덱스 컬럼을 가공해도 인덱스를 사용할 수는 있지만, 스캔 시작점을 찾을 수 없고 멈출 수도 없어 리프 블록 전체를 스캔해야 한다. 즉, 일부가 아닌 전체를 스캔하는 Index Full Scan 방식으로 작동한다. 


## 인덱스를 Range Scan 할 수 없는 이유
인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다. 

모든 SQL 튜닝 책이 공통으로 다루는 내용이다. 기본 중에서 기본에 해당한다. 튜닝을 공부한 이들 중에 이 사실을 모르는 사람은 아무도 없다. 인덱스 컬럼을 가공했을 때 인덱스를 정상적으로 사용할 수 없는 이유는 인덱스 스캔 시작점을 찾을 수 없기 때문이다. Index Range Scan에서 Range는 범위를 의미한다. 즉 Index Range Scan은 인덱스에서 일정 범위를 스캔한다는 뜻이다. 일정 범위를 스캔하려면 시작 지점과 끝 지점이 있어야 한다. 

인덱스를 정상적으로 사용한다는 표현은 리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미한다. 아래와 같은 조건절에는 인덱스를 정상적으로 사용할 수 없다. 기본적으로 Index Range Scan이 불가능하다. 단, OR 또는 IN 조건절은 옵티마이저의 쿼리변환 기능을 통해  Index Range Scan으로 처리되기도 한다. 

```sql

WHERE SUBSTR(생년월일,5,2) = '05'

WHERE nvl(주문수량, 0) < 100

WHERE 업체명 like '%대한%'

WHERE (전화번호 = :tel_no or 고객명 = :cust_nm)

WHERE 전화번호 in ( :tel_no1, :tel_no2) 

```

## 더 중요한 인덱스 사용 조건
인덱스를 [소속팀 + 사원명 + 연령]순으로 구성한다면, 데이터를 소속팀 순으로 정렬하고, 소속팀이 같으면 사원명 순으로 정렬하고, 사원명까지 같으면 연령 순으로 정렬한다는 의미이다. 이름이 같더라도 소속팀이 다르면 멀리 떨어지게 된다. 리프 블록 전 구간에 흩어진다. 이 조건으로 특정 사원명을 검색하면, 인덱스 스캔 시작점을 찾을 수가 없고, 어디서 멈춰야 할지도 알 수 없다. 인덱스 리프 블록을 처음부터 끝까지 모두 스캔해야한다. 

인덱스를 Range Scan 하기 위한 가장 첫 번째 조건은 __인덱스 선두 컬럼이 조건절에 있어야 한다__ 는 사실이다. 가공하지 않은 상태로 말이다. 

```sql

TXA1234_IX02 인덱스 : 기준연도 + 과세구분코드 + 보고회차 + 실명확인번호

SELECT * 
FROM TXA1234
WHERE 기준연도 = :stdr_year
	AND SUBSTR(과세구분코드,1,4) = :txtn_dcd
	AND 보고회차 = :rpt_tmrd
	AND 실명확인번호 = :rnm_cnfm_no

```
위와 같은 식으로 인덱스를 구성하고 쿼리한다면, 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있기 때문에 Index Range Scan이 무조건 가능하다. 인덱스 선두 컬럼인 기준연도를 조건절에서 가공하지 않았으므로 인덱스 Range Scan이 가능하다. 문제는 인덱스를 Range Scan한다고 해서 항상 성능이 좋은 건 아니라는 사실이다. 


### 인덱스 잘 타니까 튜닝 끝? 
SQL을 개발하면서 실행계획을 확인하지 않는 개발자가 대다수다. 확인하더라도 인덱스를 타는지, 안 타는지 확인하는 수준에 그친다. 인덱스를 잘 타면 성능도 문제없다고 생각한다. 아래 SQL은 인덱스를 잘 타고 있다. 우리가 흔히 말하는 인덱스를 탄다는 것은 Index Range Scan을 한다는 뜻인다. 

```
0   SELECT STATEMENT Optimizer=ALL_ROWS
1  0  TABLE ACCESS (BY INDEX ROWID) OF '주문상품' (TABLE)
2  1    INDEX (RANGE SCAN) OF '주문상품_N1' (INDEX)
```

주문상품_N1 인덱스는 [주문일자 + 상품번호]순으로 구성됐고, 이 테이블에 쌓이는 데이터량은 하루 평균 100만 건이라고 가정하자. 


```sql

SELECT *
  FROM 주문상품
 WHERE 주문일자 = :ord_dt
   AND 상품번호 LIKE '%PING%';

SELECT *
  FROM 주문상품
 WHERE 주문일자 = :ord_dt
   AND SUBSTR(상품범호,1,4)='PING';
```

위 조건절은 인덱스 선두 컬럼인 주문일자가 조건절에 있고, 가공하지 않은 상태이므로 인덱스를 Range Scan 하는 데 문제가 없다. 스캔 시작점을 찾아 스캔하다가 중간에 멈출 수 있다. 그런 의미에서 인덱스를 잘 탄다고 할 수 있다. 그런데 인덱스를 정말 잘 타는지는 인덱스 리프블록에서 스캔하는 양을 따져봐야 알 수 있다. 

위 SQL에서 상품번호는 스캔 범위를 줄이는 데 전혀 역할을 하지 못한다. 첫 번째 SQL은 중간 값 검색이기 때문에이고, 두 번째 SQL은 컬럼을 가공했기 때문이다. 따라서 위 조건절을 처리할 때 인덱스에서 스캔하는 데이터량은 주문일자 조건을 만족하는 100만 건이다. 이를 두고, 인덱스를 잘 탄다고 말할 수는 없을 것이다. 



## 인덱스를 이용한 소트 연산 생략
인덱스를 Range Scan 할 수 있는 이유는 데이터가 정렬돼 있기 때문이다. 찾고자하는 데이터가 정렬된 상태로 서로 모여있기 때문에 전체가 아닌 일정부분만 읽다가 멈출 수 있다. 인덱스 컬럼을 가공해도 인덱스를 사용할 순 있지만, 찾고자 하는 데이터가 전체 구간(테이블 전체 레코드 또는 가공하지 않은 인덱스 선두 컬럼에 의해 선택된 전체 레코드)에 흩어져 있기 때문에 Range Scan이 불가능하거나 비효율이 발생한다. 

테이블과 달리 인덱스는 정렬되어 있다. 이것이 인덱스를 사용하는 이유다. 인덱스가 정렬돼 있기 때문에 Range Scan이 가능하고, 소트 연산 생략 효과도 부수적으로 얻게 된다. 


PK를 [장비번호 + 변경일자 + 변경순번] 순으로 구성한 상태변경이력 테이블이 있다고 가정하자. 장비번호, 변경일자가 같은 레코드는 변경순번 순으로 정렬된다. 
장비번호와 변경일자를 모두 '=' 조건으로 검색할 때 PK 인덱스를 사용하면 결과집합은 변경순번 순으로 출력된다. 옵티마이저는 이런 속성을 활용하여 SQL에 ORDER BY가 있어도 정렬연산을 따로 수행하지 않는다. PK 인덱스를 스캔하면 출력한 결과집합은 어차피 변경순번 순으로 정렬되기 때문이다. 

내림차순 정렬에도 인덱스를 활용할 수 있다. 인덱스 리프블록은 양방향 연결 리스트 구조이기에 오름차순(ASC) 정렬일 때는 조건을 만족하는 가장 작은 값을 찾아 좌측으로 수직적 탐색한 후 우측으로 수평적 탐색을 한다. 내림차순 정렬일 때는 조건을 만족하는 가장 큰 값을 찾아 우측으로 수직적 탐색을 한 후 좌측으로 수평적 탐색을 한다.  인덱스로 소트 연산을 생략하여 성능을 높일 수 있다. 

## ORDER BY 절에서 컬럼 가공
인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다에서 말하는 인덱스 컬럼은 대개 조건절에 사용한 컬럼을 말한다. 그런데 조건절이 아닌 ORDER BY 또는 SELECT-LIST에서 컬럼을 가공함으로 인해 인덱스를 정상적으로 사용할 수 없는 경우도 종종 있다. 

상태변경이력 PK인덱스를 [장비번호 + 변경일자 + 변경 순번] 순으로 구성했다면, 아래 SQL도 정렬 연산을 생략할 수 있다. 수직적 탐색을 통해 장비번호가 "C"인 첫번째 레코드를 찾아 인덱스 리프 블록을 스캔하면, 자동으로 [변경일자 + 변경순번] 순으로 정렬되기 때문이다. 

```sql
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
ORDER BY 변경일자, 변경순번
```

만약 개발자가 SQL을 아래와 같이 작성한다면 정렬연산을 생략할 수 없다.

```sql
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
ORDER BY 변경일자 || 변경순번
```
인덱스를 가공하지 않은 상태로 값을 저장했는데, 가공한 값 기준으로 정렬해달라고 요청했기 때문이다. 


주문_PK 인덱스는 [주문일자 + 주문번호] 순으로 구성돼어있다고 할 때, 아래 SQL에 주문 인덱스를 사용하면 선두 컬럼인 주문일자가 '='조건이므로 데이터가 주문번호 순으로 출력된다. ORDER BY 절이 있어도 정렬연산을 생량할 수 있는 상태이다. 그런데 실행계획을 살펴보면 SORT ORDERY BY 연산이 나타난다. 

```sql

SELECT *
FROM (
	SELECT TO_CHAR(A.주문번호, 'FM000000') AS 주문번호, A.업체번호, A.주문금액
	FROM 주문 A
	WHERE A.주문일자 = :dt
	  AND A.주문번호 > NVL(:next_ord_no, 0)
	ORDER BY 주문번호
)
WHERE ROWNUM<= 30

```

그 이유는 ORDER BY절에 기술한 '주문번호'는 순수한 주문번호가 아니라 TO_CHAR 함수로 가공한 주문번호를 가리키기 때문이다. 

참고로 TO_CHAR 함수에 'FM000000'옵션을 사용하면 첫 번쨰 인자에 입력한 숫자를 '0'으로 시작하는 여섯자리 문자 값으로 변환해준다. 예를 들어 숫자 1234를 입력하면 문자 '001234'로 변환해준다. 

해결방법은 간단하다. ORDERY BY절 주문번호에 A(주문테이블 Alias)를 붙여주기만 하면 된다. 

```sql

SELECT *
FROM (
	SELECT TO_CHAR(A.주문번호, 'FM000000') AS **주문번호**, A.업체번호, A.주문금액
	FROM 주문 A
	WHERE A.주문일자 = :dt
	  AND A.주문번호 > NVL(:next_ord_no, 0)
	ORDER BY **A.주문번호**
)
WHERE ROWNUM<= 30

```




























































