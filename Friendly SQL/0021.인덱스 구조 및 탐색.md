# 인덱스 구조 및 탐색

## 인덱스 튜닝 preview

### 데이터를 찾는 두 가지 방법
어떤 초등학교를 방문해 '홍길동' 학생을 찾는 방법은 두 가지다. 첫째는 1학년 1반부터 6학년 맨 마지막 반까지 모든 교실을 돌며 홍길동 학생을 찾는 것이다. 둘째는, 교무실에서 학생명부를 조회해 홍길동 학생이 있는 교실만 찾아가는 것이다. 홍길동이 많다면 전자가 빠르고, 몇 안 되면 후자가 빠르다. 이름으로 학생을 찾는 방문객이 많다면, 학생명부를 아예 이름 순으로 정렬해 두면 편리하다. 이것이 바로 인덱스다.  "학년-반-번호" 컬럼이 인덱스의 ROWID에 해당한다. 

|이름|학년-반-번호|
|-----|----------------|
|김동철|3학년 1반 10번|
|김동철|3학년 2반 9번|
|김동철|6학년 2반 7번|
|김통철|1학년 1반 1번|
|...|...|
|홍길동| 1학년 5반 34번|
|홍길동| 2학년 6반 33번|
|홍길동| 5학년 8반 32번|


데이터베이스 테이블에서 데이터를 찾는 방법도 아래 두 가지다. 수십년에 걸쳐 DBMS가 발전해 왔는데도 이 두 방법에서 크게 벗어나지 못하고 있다. 
*  테이블 전체를 스캔한다. 
*  인덱스를 이용한다. 

앞선 예에서 모든 교실을 돌며 학생을 찾는 경우가 전자에 속하고, 이름순으로 정렬한 학생명부를 이용하는 경우 후자에 속한다. 테이블 전체 스캔과 관련해서는 튜닝요소가 많지 않지만, 인덱스와 관련해서는 튜닝 요소가 매우 많고 기법도 다양하다. 그래서 인덱스는 SQL 튜닝을 공부할 때 가장 먼저 다루어야할 주제다. 


### 인덱스 튜닝의 두 가지 핵심요소
인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용한다. 온라인 트랜잭션 처리(Online Transaction Processing, OLTP) 시스템에서는 소량 데이터를 주로 검색하므로 인덱스 튜닝이 무엇보다 중요하다. 

세부적인 인덱스 튜닝 방법으로 여러 가지가 있지만, 핵심요소는 크게 두 가지로 나뉜다. 첫번째는 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것이다. 즉 __인덱스 스캔 효율화 튜닝__ 이다.

학생명부에서 시력이 1.0 ~ 1.5인 홍길동 학생을 찾는 경우 이름과 시력순으로 정렬해 두었다면 소량만 스캔하면 된다. 반면, 학생명부를 시력과 이름순으로 정렬해두었다면, 똑같이 두 명을 찾는데도 많은 양을 스캔해야 한다. 

인덱스 튜닝의 두 번째 핵심요소는 테이블 엑세스 횟수를 줄이는 것이다. 인덱스 스캔 후 테이블 레코드를 액세스할 때 랜덤 I/O 방식을 사용하므로 이를 __랜덤 액세스 튜닝__ 이라고 한다. 


인덱스 스캔 효율화 튜닝과 랜덤 액세스 최소화 튜닝 둘 다 중요하지만, 더 중요한 하나를 고른다면 랜덤 액세스 최소화 튜닝이다. 성능에 미치는 영향이 더 크기 때문이다. 


### SQL 튜닝은 랜덤 I/O와의 전쟁
데이터베이스 성능이 느린 이유는 디스크 I/O 때문이다. 읽어야 할 데이터량이 많고, 그 과정에 디스크 I/O가 많이 발생할 때 느리다. 인덱스를 많이 사용하는 OLTP 시스템이라면 디스크 I/O 중에서도 랜덤 I/O가 특히 중요하다. 

성능을 위해 DBMS가 제공하는 많은 기능이 느린 랜덤 I/O를 극복하기를 위해 개발됐다. IOT, 클러스터, 파이션에서부터 테이블 Prefetch, Batch I/O처럼 겉으로 잘 드러나지 않는 숨은 기능까지 모두가 그렇다. 이들 기능의 본질은 랜덤 I/O를 줄이는데 있다. 

조인 메소드 중 가장 일반적으로 사용하는 NL 조인이 대량 데이터 조인할 때 느린 이유도 랜덤 I/O 때문이다. 그래서 소트머지 조인과 해시 조인이 개발됐으므로 이들 조인 메소드도 결국 느린 랜덤 I/O를 극복하기 위해서 개발된 기능이다. 그만큰 랜덤 I/O가 그만큼 중요하다. 


## 인덱스 구조
인덱스는 대용량 테이블에서 필요한 데이터만 빠르게 효율적으로 액세스하기 위해 사용하는 오브젝트다. 데이터베이스에서도 인덱스 없이 데이터를 검색하려면, 테이블을 처음부터 끝까지 모두 읽어야 한다. 반면, 인덱스를 이용하면 일부만 읽고 멈출 수 있다. 즉, 범위스캔이 가능하다. 범위 스캔이 가능한 이유는 인덱스가 정렬돼 있기 때문이다. DBMS는 일반적으로 B\*Tree 인덱스를 사용한다. 루트와 브랜치 블록에 있는 각 레코드는 하위 블록에 대한 주소값을 갖는다. 키값은 하위 블록에 저장된 키값의 범위를 나타낸다. 예를 들어 고객이 이름을 저장하고 있는 테이블에서, 루트블록 '서' 레코드가 가리키는 하위 블록에는 '서'보다 크거나 같은 레코드가 저장돼 있다는 뜻이다. 

루트와 브랜치 블록에는 키값을 갖지 않는 특별한 레코드가 하나 있다. 가장 왼쪽 첫 번째 레코드다. 이를 LMC 라고 하며 Leftmost Child의 줄임말이다. LMC는 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킨다. LMC가 가리키는 주소를 찾아간 블록에는 키값을 가진 첫 번째 레코드보다 작거나 같은 레코드가 저장돼 있다. 

리프 블록에 저장된 각 레코드는 키값 순으로 정렬돼 있을 뿐만 아니라 테이블 레코드를 가리키는 주소값, 즉 ROWID를 갖는다. 인덱스 키값이 같으면 ROWID 순으로 정렬된다. 인덱스를 스캔하는 이유는 검색 조건을 만족하는 소량의 데이터를 빨리 찾고 거기서 ROWID를 얻기 위해서다. ROWID는 아래와 같이 데이터 블록 주소(DBA, Data Block Address)와 로우 번호로 구성되므로 이 값을 알면 테이블 레코드를 찾아갈 수 있다. 
* ROWID = 데이터 블록 주소 + 로우 번호
* 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
* 블록 번호: 데이터 파일 내에서 부여한 상대적 순번 
* 로우 번호: 블록 내 순번

인덱스 탐색 과정은 수직적 탐색과 수평적 탐색으로 나눌 수 있다. 
* 수직적 탐색: 인덱스 스캔 시작지점을 찾는 과정
* 수평정 탐색: 데이터를 찾는 과정


## 인덱스 수직적 탐색
정렬된 레코드 중 조건을 만족하는 첫 번째 레코드를 찾는 과정이다. 즉, 인덱스 스캔 시작지점을 찾는 과정이다. 인덱스 수직적 탐색은 루트(Root)블록에서 부터 시작한다. 루트를 포함해 브랜치 블록에 저장된 각 인덱스 레코드 하위 블록에 대한 주소값을 갖는다. 루트에서 시작해서 리프블록까지 수직적 탐색이 가능한 이유다. 

수직적 탐색과정에서 찾고자 하는 값보다 크거나 같은 값을 만나면, 바로 직전 레코드가 가리키는 하위블록으로 이동한다. 목표 값을 찾았다고 하더라도 그 레코드가 가리키는 하위블록으로 이동하면 안된다. 바로 직전 레코드가 가리키는 하위블록으로 이동해야 빠지는 레코드 없이 탐색할 수 있다. 수직적 탐색은 __조건을 만족하는 레코드를 찾는 과정이 아니라 조건을 만족하는 첫 번째 레코드__ 를 찾는 과정이다. 

인덱스를 수직적으로 탐색할 때, 루트를 포함한 브랜치 블록은 등산푯말 같은 역할을 한다. 조건을 만족하는 첫번째 레코드가 목표지점이다. 폿말을 만날 때마다 어느쪽으로 가면 목표 레코드를 만날 수 있는지 확인하면서 이동한다. 푯말이 알려주는 대로 따라가다보면 조건을 만족하는 첫번째 레코드를 만날 수 있다. 


## 인덱스 수평적 탐색
수직적 탐색을 통해 스캔 시작점을 찾았으면 찾고자 하는 데이터가 더 안 나타날 때까지 인덱스 리프 블록을 수평적으로 스캔한다. 인덱스에서 본격적으로 데이터를 찾는 과정이다. 인덱스 리프블록끼리는 서로 앞뒤 블록에 대한 주소값을 갖는다. 즉 양방향 연결 리스트 구조다. 좌에서 우로, 또는 우에서 좌로 수평적 탐색이 가능한 이유다. 
인덱스를 수평적으로 탐색하는 이유는 첫째, 조건절을 만족하는 데이터를 모두 찾기 위해서고, 둘째 ROWID를 얻기 위해서다. 필요한 컬럼을 인덱스가 모두 갖고 있어 인덱스만 스캔하고 끝나는 경우도 있지만, 일반적으로 인덱스를 스캔하고 테이블도 액세스한다. 이때 ROWID가 필요하다. 


## 결합 인덱스 구조와 탐색
두 개 이상의 컬럼을 결합해서 인덱스를 만들 수도 있다. 고객 테이블에 성별과 고객명을 기준으로 인덱스를 만들 수도 있는 것이다. 인덱스를 [고객명 + 성별]로 구성하든, [성별 + 고객명]으로 구성하든 읽는 인덱스 블록 개수가 똑같다. 인덱스 선두 컬럼을 모두 "=" 조건으로 검색할 때는 어느 컬럼을 인덱스 앞쪽에 두든 블록I/O 개수가 같으므로 성능도 똑같다. 












